# app/services/api_client.py
# api_client.py version: 2025-06-27-v6
import requests
import time
import copy
import redis
from datetime import datetime, timedelta, timezone
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from config import (
    API_USERNAME,
    API_PASSWORD,
    LOGIN_URL,
    INCREMENTAL_FALLBACK_SECONDS,
    LOG_FILE,
)
import logging
from urllib.parse import quote
from contextlib import nullcontext
from .. import cache
from .logger import get_logger
from ..utils.exceptions import APIException, log_and_handle_exception

# Configure logging
logger = get_logger("api_client", level=logging.INFO, log_file=LOG_FILE)


def create_session():
    """Create a new requests session with retry strategy."""
    session = requests.Session()
    retry_strategy = Retry(
        total=5,
        backoff_factor=1,
        allowed_methods=["GET", "POST", "PATCH"],
        status_forcelist=[500, 502, 503, 504],
    )
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    return session


class APIClient:
    """
    RFID API client for handling authentication and requests.

    Note: This client is not thread-safe. Each thread should use its own instance
    since the session and token are instance attributes that may be modified
    during requests (e.g., token refresh).
    """

    def __init__(self):
        # DISABLED: RFIDpro API integration removed to prevent data corruption
        logger.info("RFIDpro API client initialized in DISABLED mode")
        self.base_url = "https://cs.iot.ptshome.com/api/v1/data/"
        self.auth_url = LOGIN_URL
        self.item_master_endpoint = "14223767938169344381"
        self.token = "DISABLED_MODE"
        self.token_expiry = None
        self.session = create_session()  # Instance-specific session
        # Skip authentication - API integration is disabled
        logger.info("RFIDpro API authentication skipped - running in disabled mode")

    def authenticate(self):
        """DISABLED: RFIDpro API authentication disabled to prevent data corruption"""
        logger.info("RFIDpro API authentication call skipped - running in disabled mode")
        self.token = "DISABLED_MODE"
        self.token_expiry = datetime.now() + timedelta(days=365)  # Set far future expiry
        return True

    def _make_request(
        self,
        endpoint_id,
        params=None,
        method="GET",
        data=None,
        timeout=20,
        user_operation=False,
        headers=None,
    ):
        """DISABLED: All RFIDpro API requests disabled to prevent data corruption"""
        logger.info(f"RFIDpro API request blocked - {method} to endpoint {endpoint_id}")
        # Return empty response to prevent application errors
        return []

    def validate_date(self, date_str, field_name):
        if date_str is None or date_str == "0000-00-00 00:00:00":
            logger.debug(f"Null or invalid {field_name}: {date_str}, returning None")
            return None
        try:
            return datetime.strptime(date_str, "%Y-%m-%d %H:%M:%S")
        except ValueError:
            try:
                return datetime.fromisoformat(date_str.replace("Z", "+00:00"))
            except ValueError as e:
                logger.warning(
                    f"Invalid {field_name}: {date_str}. Error: {str(e)}. Returning None."
                )
                return None

    def get_item_master(self, since_date=None, full_refresh=False):
        """DISABLED: RFIDpro API get_item_master disabled to prevent data corruption"""
        logger.info("RFIDpro API get_item_master call blocked - returning empty list")
        return []

    def get_transactions(self, since_date=None, full_refresh=False):
        params = {}
        all_data = []
        if since_date and not full_refresh:
            since_date_str = (
                since_date.strftime("%Y-%m-%d %H:%M:%S")
                if isinstance(since_date, datetime)
                else since_date
            )
            logger.debug(f"Transactions filter since_date: {since_date_str}")
            filter_str = f"scan_date,gt,'{since_date_str}'"
            params["filter[gt]"] = filter_str
            try:
                data = self._make_request("14223767938169346196", params, timeout=20)
                all_data = data
                logger.info(
                    f"Fetched {len(all_data)} transactions with since_date filter"
                )
                return all_data  # Return early if since_date filter is used
            except Exception as e:
                logger.warning(
                    f"Filter failed: {str(e)}. Skipping fetch for incremental refresh."
                )
                return []  # Skip fetching all data for incremental refresh
        # Full refresh or no since_date
        params.pop("filter[gt]", None)
        all_data = self._make_request("14223767938169346196", params, timeout=20)
        logger.info(f"Fetched {len(all_data)} transactions without since_date filter")
        if since_date and full_refresh:
            since_dt = self.validate_date(since_date_str, "since_date")
            if since_dt:
                fallback_dt = datetime.now(timezone.utc) - timedelta(
                    seconds=INCREMENTAL_FALLBACK_SECONDS
                )
                all_data = [
                    item
                    for item in all_data
                    if item.get("scan_date") is None
                    or (
                        self.validate_date(item.get("scan_date"), "scan_date")
                        and self.validate_date(item.get("scan_date"), "scan_date")
                        > max(since_dt, fallback_dt)
                    )
                ]
                logger.info(
                    f"Filtered to {len(all_data)} transactions locally after fetching all"
                )
        return all_data

    def get_seed_data(self, since_date=None):
        params = {}
        data = self._make_request("14223767938169215907", params, timeout=20)
        logger.info(f"Fetched {len(data)} seed rental classes")
        return data

    def update_bin_location(self, tag_id, bin_location, timeout=20):
        if not tag_id or not bin_location:
            raise ValueError("tag_id and bin_location are required")

        params = {"filter[eq]": f"tag_id,eq,'{tag_id}'"}
        items = self._make_request(self.item_master_endpoint, params, timeout=timeout)
        if not items:
            raise Exception(f"Item with tag_id {tag_id} not found in Item Master")

        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        update_data = [
            {
                "tag_id": tag_id,
                "bin_location": bin_location,
                "date_last_scanned": current_time,
            }
        ]

        response = self._make_request(
            self.item_master_endpoint,
            params=params,
            method="PATCH",
            data=update_data,
            timeout=timeout,
            user_operation=True,
        )
        logger.info(
            f"Updated bin_location for tag_id {tag_id} to {bin_location} via API"
        )
        return response

    def update_status(self, tag_id, status, timeout=20):
        if not tag_id or not status:
            raise ValueError("tag_id and status are required")

        params = {"filter[eq]": f"tag_id,eq,'{tag_id}'"}
        items = self._make_request(self.item_master_endpoint, params, timeout=timeout)
        if not items:
            raise Exception(f"Item with tag_id {tag_id} not found in Item Master")

        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        update_data = [
            {"tag_id": tag_id, "status": status, "date_last_scanned": current_time}
        ]

        response = self._make_request(
            self.item_master_endpoint,
            params=params,
            method="PATCH",
            data=update_data,
            timeout=timeout,
            user_operation=True,
        )
        logger.info(f"Updated status for tag_id {tag_id} to {status} via API")
        return response

    def update_notes(self, tag_id, notes):
        if not tag_id:
            raise ValueError("tag_id is required")

        params = {"filter[eq]": f"tag_id,eq,'{tag_id}'"}
        items = self._make_request(self.item_master_endpoint, params)
        if not items:
            raise Exception(f"Item with tag_id {tag_id} not found in Item Master")

        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        update_data = [
            {
                "tag_id": tag_id,
                "notes": notes if notes else "",
                "date_updated": current_time,
            }
        ]

        response = self._make_request(
            self.item_master_endpoint,
            params=params,
            method="PATCH",
            data=update_data,
            user_operation=True,
        )
        logger.info(f"Updated notes for tag_id {tag_id} to '{notes}' via API")
        return response

    def insert_item(self, item_data, timeout=20):
        if not item_data or "tag_id" not in item_data:
            raise ValueError("item_data must contain a tag_id")

        response = self._make_request(
            self.item_master_endpoint,
            method="POST",
            data=[item_data],
            timeout=timeout,
            user_operation=True,
        )
        logger.info(f"Inserted new item with tag_id {item_data['tag_id']} via API")
        return response
